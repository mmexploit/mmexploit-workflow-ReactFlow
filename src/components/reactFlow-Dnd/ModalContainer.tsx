import { Modal } from "@mantine/core";
import { Button } from "@mantine/core";
import { useCallback, useState } from "react";
import { Node, ReactFlowInstance } from "reactflow";
import React from "react"
import { useDispatch } from "react-redux";
import { addNode } from "../../redux/nodes";
import { addEdge } from "../../redux/edges";
import { useSelector } from "react-redux";
import { getHandleColor, getHandleId } from "../../redux/handle";
import { RootState } from "../../redux/store";
import { MarkerType } from "reactflow";
import { getfullNodes } from "../../redux/nodes";
import { useEffect } from "react";


const ModalContainer = ( {opened, onClose, returned, fromEdge, edgeId, otherProps}) => {

    const dispatch = useDispatch()
    const handletype = useSelector((state: RootState) => state.handle)

    const edges = useSelector((state: RootState) => state.edges.edges)
    const nodes = useSelector((state: RootState) => state.nodes.nodes)

    const [isLoaded, setIsLoaded] = useState(false);

    const nodesf = useSelector((state: RootState) => state.nodes.nodesf)
    const sourceHandle = getHandleId(handletype)

    const strokeColor = getHandleColor(handletype);
    const nodesFull = useSelector(getfullNodes)

    const [recallHandleEdge, setRecallHandleEdge] = useState(false);

    useEffect(() => {
        const checkNodes = () => {
          if (nodesFull.length !== nodes.length) {
            setTimeout(checkNodes, 100); // Wait for 100ms before checking again
          } else {
            setIsLoaded(true);
          }
        };
    
        checkNodes();
      }, [nodesFull, nodes.length]);

      useEffect(() => {
        if(recallHandleEdge) {
            console.log("useEffect called")
            handleEdgeFromClick("request",edgeId, "test label")
        }
      }, [recallHandleEdge, edgeId])

      console.log({isLoaded})
      console.log("nodesFull called from outside handleEdgeFromClick",{nodesFull})

    const getaddedNode = useCallback(
        (id) => nodesFull.find(n => n.id === id),
        [nodesFull]
      );

    
    const handleButtonClickFromEdge = ( type, id, label) => {

        console.log("nodes full called from within handleButtonClickFromEdge",{nodesFull})

        // Find the edge with ID "3-4"
        const edge = edges.find(e => e.id === edgeId);

        // Find the source node of the edge
        const sourceNode = nodes.find(n => n.id === edge.source);

        // Find the target node of the edge
        const targetNode = nodes.find(n => n.id === edge.target);

        const position = {
            x: sourceNode.position.x ,
            y: sourceNode.position.y + 60
        }

        const newNode = {
            id: `${id}`,
            type: type,
            position,
            data: { label: label, connected: false}
        };

        dispatch(addNode(newNode))
    }

    const handleEdgeFromClick = async (type, id, label) => {

        console.log("nodes full called from within handleEdgeFromClick", {nodesFull})

        // Find the edge with ID "3-4"
        const edge = edges.find(e => e.id === edgeId);

        // Find the source node of the edge
        const sourceNode = nodes.find(n => n.id === edge.source);

        // Find the target node of the edge
        const targetNode = nodes.find(n => n.id === edge.target);

        // while (nodesFull.length !== nodes.length) {
        //     await new Promise((resolve) => setTimeout(resolve, 1000));
        //   }

          console.log("fully populated", nodesFull)

            console.log("function getting called because nodefull is fetched")
            console.log({nodesFull})
            let addedNode = getaddedNode(id)
            console.log({addedNode})
            // const symbolProp = Object.getOwnPropertySymbols(addedNode)
            // const handleBounds = (addedNode as unknown as any)[symbolProp[0]].handleBounds
            // console.log('Handles:', addedNode);

            console.log({sourceNode})
            console.log({targetNode})

        const newEdge1 = {
            id: `${sourceNode.id}-${id}` ,
            source: `${sourceNode.id}`,
            sourceHandle: sourceHandle,
            target: `${id}`,
            targetHandle: returned ? "Returned-left" : "in",
            animated: false,
            style: { stroke: `${strokeColor}` },
            type: "buttonedge",
            label: `${handletype.label}`,
            markerEnd: {
              type: MarkerType.ArrowClosed,
              width: 20,
              height: 20,
              color: strokeColor,
            },
        }

        const newEdge2 = {
            id: `${id}-${targetNode.id}` ,
            source: `${id}`,
            sourceHandle: sourceHandle,
            target: `${targetNode.id}`,
            targetHandle: returned ? "Returned-left" : "in",
            animated: false,
            style: { stroke: `${strokeColor}` },
            type: "buttonedge",
            label: `${handletype.label}`,
            markerEnd: {
              type: MarkerType.ArrowClosed,
              width: 20,
              height: 20,
              color: strokeColor,
            },
        }

        dispatch(addEdge(newEdge1));
        dispatch(addEdge(newEdge2));

        setRecallHandleEdge(false)
    }

    const handleButtonClick = ( type, id, label ) => {

        const position = {
            x: otherProps.xPos / 2,
            y: otherProps.yPos + 120
        }

        const newNode = {
            id: `${id}`,
            type: type,
            position,
            data: { label: label, connected: false },
          };
          dispatch(addNode(newNode));
      
          const newEdge = {
            id: `${otherProps.id}-${id}` ,
            source: `${otherProps.id}`,
            sourceHandle: sourceHandle,
            target: `${id}`,
            targetHandle: returned ? "Returned-left" : "in",
            animated: false,
            style: { stroke: `${strokeColor}` },
            type: "buttonedge",
            label: `${handletype.label}`,
            markerEnd: {
              type: MarkerType.ArrowClosed,
              width: 20,
              height: 20,
              color: strokeColor,
            },
          };
          dispatch(addEdge(newEdge));
    } 

    return (<>
        <Modal opened={opened} onClose={onClose} title="Please select task from below available ones" centered>
            <div className="flex flex-col">
                <Button className="bg-blue-700 hover:bg-blue-800 mb-2" 
                onClick={async () => {
                    const label = "Submit service request for reg ..."
                    if(fromEdge) {
                        handleButtonClickFromEdge("request", 3, label)
                        handleEdgeFromClick("request", 3, label)
                    }
                    else{ handleButtonClick("request", 3, label) }
                    onClose()
            }}>Submit service request for reg ...</Button>
            <Button className="bg-blue-700 hover:bg-blue-800 mb-2"
                onClick={() => {
                    const label = "Review compliance with service ..."
                    if(fromEdge) {
                        handleButtonClickFromEdge("review", 4, label)
                        handleEdgeFromClick("review", 4, label)
                    } else
                    { handleButtonClick("review", 4, label) }
                    onClose()
            }}>Review compliance with service ...</Button>
            <Button className="bg-blue-700 hover:bg-blue-800 mb-2"
                onClick={() => {
                    const label = "Invoice - Payment for registra ..."
                    if(fromEdge) {
                        handleButtonClick("request", 5, label)
                        handleEdgeFromClick("request", 5, label)
                    } else {
                        handleButtonClick("request", 5, label)
                    }
                    onClose()
            }}>Invoice - Payment for registra ...</Button>
            <Button className="bg-red-700 hover:bg-red-800 mb-2 text-white"
                onClick={() => {
                    const label = "End"
                    handleButtonClick("request", 2, label)
                    setRecallHandleEdge(true)
                    onClose()
            }}>End</Button>
            </div>
            
        </Modal>
    </>)
}

export default ModalContainer;

// From the two array I want to use the edge Id to get the specific edge then use the source and target ids to get properties of both the target and and source nodes from the nodes array

// edges: [{
//     "id": "3-4",
//     "source": "3",
//     "sourceHandle": "Yes",
//     "target": "4",
//     "targetHandle": "in",
//     "animated": false,
//     "style": {
//         "stroke": ""
//     },
//     "type": "buttonedge",
//     "label": "Yes",
//     "markerEnd": {
//         "type": "arrowclosed",
//         "width": 20,
//         "height": 20,
//         "color": ""
//     }
// }]

// nodes: [{
//     "id": "2",
//     "type": "end",
//     "data": {
//         "label": "End"
//     },
//     "position": {
//         "x": 756.7932572510128,
//         "y": 1115.0229916856513
//     },
//     "width": 48,
//     "height": 48,
//     "selected": false,
//     "positionAbsolute": {
//         "x": 756.7932572510128,
//         "y": 1115.0229916856513
//     },
//     "dragging": false
// }]

// const nodes = [...]; // Array of nodes
// const nodeIds = ["1", "2", "3"]; // Array of node IDs to fetch

// const fetchedNodes = nodeIds.map(nodeId => reactFlowInstance.getNode(nodeId));
// // Loop through the node IDs, fetch each node by its ID, and push it into a new array

// const node = reactFlowInstance.getNode("1"); // The original node
// const nodesArray = [node, ...fetchedNodes]; // Combine the original node with the fetched nodes

// console.log(nodesArray); // The final array of nodes
