import { Modal } from "@mantine/core";
import { Button } from "@mantine/core";
import { useState } from "react";
import React from "react";
import { useDispatch } from "react-redux";
import { addNode, updatePosition } from "../../redux/nodes";
import { addEdge, removeEdge } from "../../redux/edges";
import { useSelector } from "react-redux";
import { getHandleColor, getHandleId, HandleColors } from "../../redux/handle";
import { RootState } from "../../redux/store";
import { MarkerType } from "reactflow";
import { nodesList } from "./node";
import { Select } from "@mantine/core";
import { Form, useForm } from "@mantine/form";

interface Props {
  opened: boolean;
  onClose: () => void;
  returned: boolean;
  fromEdge: boolean;
  edgeId: string;
  otherProps: any
}

const ModalContainer: React.FC<Props> = ({
  opened,
  onClose,
  returned,
  fromEdge,
  edgeId,
  otherProps,
}) => {
  const dispatch = useDispatch();
  const handletype = useSelector((state: RootState) => state.handle);

  const edges = useSelector((state: RootState) => state.edges.edges);
  const nodes = useSelector((state: RootState) => state.nodes.nodes);

  const [modalContent, setModalContent] = useState("ModalContent1");

  const [choosenTask, setChoosenTask] = useState(null);

  const sourceHandle = getHandleId(handletype);

  const strokeColor = getHandleColor(handletype);
  const tasksList = nodesList.filter(node => {
    return node.id === 2 || !nodes.some(n => n.id === node.id.toString());
  });


  const handles = {
    start: ["default"],
    request: ["Yes"],
    review: ["ReviewApprove", "ReviewReject", "ReviewAdjust"],
    confirmation: ["ConfirmationYes", "ConfirmationNo"],
    payment: ["ElectronicPayment", "CashPayment"],
    end: []
  };

  const addCustomEdge = ({id, source, sourceHandle, target, strokeColor, label, targetHandle = returned ? "Returned-left" : "in"}) => {
    const newEdge = {
      id: `${id}`,
      source: `${source}`,
      sourceHandle: sourceHandle,
      target: `${target}`,
      targetHandle: `${targetHandle}`,
      animated: false,
      style: { stroke: `${strokeColor}` },
      type: "buttonedge",
      label: `${label}`,
      markerEnd: {
        type: MarkerType.ArrowClosed,
        width: 20,
        height: 20,
        color: strokeColor,
      },
    }

    dispatch(addEdge(newEdge))
  }


  const handleAddNodeFromEdge = (type: string, id: string, label: string) => {
    if(handles[type].length > 1) {
        setModalContent("ModalContent2")
        return
    }
    const edge = edges.find((e) => e.id === edgeId);

    // Find the source node of the edge
    const sourceNode = nodes.find((n) => n.id === edge.source);

    // Find the target node of the edge
    const targetNode = nodes.find((n) => n.id === edge.target);

    const position = {
      x: 85,
      y: targetNode.position.y,
    };

    const newNode = {
      id: `${id}`,
      type: type,
      position,
      data: { label: label },
    };

    dispatch(updatePosition({ addedNode: id, y: targetNode.position.y }));

    dispatch(addNode(newNode));

    handleAddEdgeFromEdge(type, id, label);
  };

  const handleAddEdgeFromEdge = (type, id, label) => {
    const edge = edges.find((e) => e.id === edgeId);

    const nodeType = type;

    // Find the source node of the edge
    const sourceNode = nodes.find((n) => n.id === edge.source);

    // Find the target node of the edge
    const targetNode = nodes.find((n) => n.id === edge.target);

    // console.log({sourceNode})
    // console.log({targetNode})

    addCustomEdge({id: `${sourceNode.id}-${id}`, source: sourceNode.id, sourceHandle: handles[sourceNode.type][0], target: `${id}`, strokeColor: `${strokeColor}`, label: `${edge.label}`})

    addCustomEdge({id: `${id}-${targetNode.id}`, source: id, sourceHandle: handles[nodeType][0], target: `${targetNode.id}`, strokeColor: `${strokeColor}`, label: ``})

    dispatch(removeEdge(edgeId));
  };

  const handleAddNodeAndEdgeFromHandle = (type: string, id: string, label: string) => {

    const position = {
      x: 85,
      y: otherProps.yPos + 120,
    };

    const newNode = {
      id: `${id}`,
      type: type,
      position,
      data: { label: label },
    };
    dispatch(addNode(newNode));

    // ${handletype.label}
    const handleLabels = handles[otherProps.type];

    addCustomEdge({id: `${otherProps.id}-${id}`, source: `${otherProps.id}`, sourceHandle: sourceHandle, target: `${id}`, strokeColor: `${strokeColor}`, label: handleLabels && handleLabels.length > 1 ? `${handletype.label}` : ``})

    onClose();
    setModalContent("ModalContent1")
  };

  const handleClick = (type: string, id: string, label: string) => {
    if (fromEdge) {
      handleAddNodeFromEdge(type, id, label);
    } else {
      handleAddNodeAndEdgeFromHandle(type, id, label);
    }
  };

  const renderButton = (button: {
    label: string;
    type: string;
    id: any;
  }) => (
    <Button
      key={button.id}
      onClick={() => {
        setChoosenTask(button);
        setModalContent("ModalContent2");
        handleClick(button.type, button.id, button.label);
      }}
      className="bg-blue-700 hover:bg-blue-800 mb-2"
    >
      {button.label}
    </Button>
  );

  const [searchValue, onSearchChange] = useState("");
  const [handlesData, setHandlesData] = useState({});

  const initialFormValues = {};
  if (choosenTask) {
    handles[choosenTask.type].forEach((handle) => {
      initialFormValues[handle] = "";
    });
  }

  const form = useForm({
    initialValues: initialFormValues,
  });

  const dropDownTasks = nodes
  .filter(node => node.id !== "1") // Exclude node with id of "1"
  .map(node => ({
    value: node.id,
    label: node.data.label || `Node ${node.id}`,
    disabled: false
  }));

  const handleSelectChange = (value: string, task: string) => {
    setHandlesData({ ...handlesData, [task]: value });
  };

  const handleSubmit = () => {
    console.log("Selected handles:", handlesData);

    const edge = edges.find((e) => e.id === edgeId);

    // Find the source node of the edge
    const sourceNode = nodes.find((n) => n.id === edge.source);

    // Find the target node of the edge
    const targetNode = nodes.find((n) => n.id === edge.target);

    const position = {
      x: 85,
      y: targetNode.position.y,
    };

    dispatch(
      addNode({
        id: `${choosenTask.id}`,
        type: choosenTask.type,
        position,
        data: { label: choosenTask.label },
      })
    );

    addCustomEdge({id: `${sourceNode.id}-${choosenTask.id}`, source: `${sourceNode.id}`, sourceHandle: edge.sourceHandle, target: `${choosenTask.id}`, strokeColor: `${strokeColor}`, label: `${edge.label}`})


    const handleColors = HandleColors

    handles[choosenTask.type].forEach((handle) => {
      const strokeColor2 = handleColors[handle]
      console.log({strokeColor2})
      addCustomEdge({id: `${choosenTask.id}-${handlesData[handle]}`, source: `${choosenTask.id}`, sourceHandle: handle, target: `${handlesData[handle]}`, strokeColor: `${strokeColor2}`, label: `${handle}`, targetHandle: handle==="ReviewAdjust" ? "Returned-left" : "in"})
      
    });

    dispatch(updatePosition({ addedNode: choosenTask.id, y: targetNode.position.y }));

    dispatch(removeEdge(edgeId));
  };

  const getModalContent = () => {
    switch (modalContent) {
      case "ModalContent1":
        return (
          <>
            <Modal.Title></Modal.Title>
            <Modal.Body>
              Please select task from the below available ones.
              <div className="flex flex-col">{tasksList.map(renderButton)}</div>
            </Modal.Body>
          </>
        );
      case "ModalContent2":
        return (
          <>
            <Modal.Title></Modal.Title>
            <Modal.Body>
              <Form form={form} onSubmit={handleSubmit}>
                <div className="mt-2 mb-2">
                  <p className="mb-4">
                    You chose a task with more than one output. Please assign to
                    which each handle should go to below.
                  </p>
                  {choosenTask && (
                    <div>
                      {handles[choosenTask.type].map((handle) => (
                        <div className="mb-2" key={handle}>
                          <Select
                            label={handle}
                            data={dropDownTasks}
                            placeholder="Pick a task"
                            onChange={(event) =>
                              handleSelectChange(event, handle)
                            }
                            value={handlesData[handle]}
                            withAsterisk
                          />
                        </div>
                      ))}
                    </div>
                  )}
                  <Button
                    type="submit"
                    className="mt-4 mb-4 float-right"
                    color="blue"
                    variant="outline"
                  >
                    Continue
                  </Button>
                </div>
              </Form>
            </Modal.Body>
          </>
        );
    }
  };

  const handleClose = () => {
    onClose();
    setModalContent("ModalContent1");
  };

  return (
    <>
      <Modal opened={opened} onClose={handleClose} centered>
        {getModalContent()}
      </Modal>
    </>
  );
};

export default ModalContainer;


