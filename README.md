# React Flow with an example WorkFlow

This is a demo project I did to present, and in the process learn about the inner workings of [React Flow](https://reactflow.dev/) - A highly customizable React component for building node-based editors and interactive diagrams. I have tried to code an interactive UI used to generate a workflow diagram, where you can select from tasks, drag and drop them and connect them with each other to form a workflow diagram. I have documented my journey below, including areas I fell short on and will keep on working from the feedbacks and help I will get from my mentors. Let's get into it.

## Table of contents

- [Overview](#overview)
  - [Introduction](#introduction)
  - [Screenshot](#screenshot)
- [My process](#my-process)
  - [Built with](#built-with)
  - [What I learned](#what-i-learned)
  - [Continued development](#continued-development)
  - [Useful resources](#useful-resources)
- [Author](#author)

## Overview

### Introduction

Before defining what React Flow is and showcase how it can be used to generate a work-flow diagram first let us define what WorkFlow Diagram is. A workflow diagram is a type of flowchart that illustrates the sequence of steps in a process or system. It is often used to visualize and document the steps involved in a specific workflow, such as a business process or a software development project. 
The diagram can be used to analyze and improve the efficiency and effectiveness of the workflow, as well as to communicate the process to others. And React Flow is a toolset built upon React to make this process of making one in an interactive manner easier.

### Screenshot

![](./public/Screenshot%202023-01-21%20114147.jpg)
![](./public/Screenshot%202023-01-21%20183512.jpg)

## My process
As shown above that is the workflow diagram, as a demo for school registration workflow, with draggable tasks on the right and a custom panel to drop and draw the diagram on on the left. The default controls of zoom in, zoom out, put diagram in optimal view, and lock the components on the diagram from moving independently are also included on the left bottom.

I have tried to use Redux Toolkit to manage state as there were dependent components that share a common state but have no way of connecting them unless I use a global state manager. I will detail why and how I incorporated that with some code snippets below, and also the problems it brought along with it.


### Built with

- [React Typescript](https://www.typescriptlang.org/)
- [Tailwind CSS](https://tailwindcss.com/)
- [Redux Toolkit](https://redux-toolkit.js.org/)
- [React Flow](https://reactflow.dev/)

### What I learned

This section is to recap over some of my major learnings while working through this project. I will try to detail what I incorporated with some code snippets and why I incorporated them.

To begin with React Flow comes preloaded with functions allowing it to build the diagrams appropriately. Let me explain some of them first. 

Nodes and edges: The first ones are of course the nodes which are our tasks or entities of the workflow diagram. And the edges being the arrows linking them. Here's how they get reinitialized and used.

```JSX
//Inital node I used which are the default nodes of Start and End. Also notice the way the data of each node is structured- id being the unique ID identifying the nodes, type being an identifier for the React Flow structure to identify its type, data including the label with which it is presented and postion on the panel, which is draggable and customizable. 
const initialNodes: Node[] = [
  {
    id: '1',
    type: 'start',
    data: { label: 'Start' },
    position: { x: 200, y: 150 },
  },
  {
    id: '2',
    type: 'end',
    data: { label: 'End'},
    position: { x: 400, y: 600},
  }
];

//The useState hook or specifcally for React Flow case the useNodeState hook that populates the initial nodes that come by default (start and end in my case) and two other functions setNodes and onNodesChange which are used to set new Nodes on each drop on the panel and passed to the React Flow Provider.
const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
const [edges, setEdges, onEdgesChange] = useEdgesState<Edge[]>([]);
```
Next up are some of the built in functions I used and come predefined in React Flow.

- onConnect - gets called whenever a new edge or linkage is formed between two nodes/tasks. It adds new edge to the nodes of interest. 
Throughout those functions you will notice most of them are wrapped in a useCallback function or useMemo to memoize the variables assigned. This is to avoid re-rendering of the components again and again without a change in the dependency affecting them. This will save us memory usage and performance issues.

```JSX
const onConnect = useCallback(
    (connection: Connection) => setEdges((eds) => addEdge(connection, eds)),
    [setEdges]
  );
```
- onDrop - the main function at play that gets called when we drop a node from the task list onto the panel. I have broken up the code into many snippets to explain each actor at play better.

```JSX
//This function gets called everytime a new node is selected, dragged and dropped onto the panel 
const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const reactFlowBounds = reactFlowWrapper.current!.getBoundingClientRect();
      const type = event.dataTransfer.getData('application/reactflow');

      // check if the dropped element is valid
      if (typeof type === 'undefined' || !type) {
        return;
      }

      //add new node using an id we get from getId() function defined above that generates random ids for each node to differntiate one from another. The type of the node - there is a start, end and custom nodes for my specific case. A label populated with the nodeName that comes from Redux Toolkit
      const newNode: Node = {
        id: getId(),
        type,
        position,
        data: { label: nodeName },
      };

      setNodes((nds: Node[]) => nds.concat(newNode));
      console.log(nodes)
    },
    [reactFlowInstance, nodeName]
  );
```
```JSX
const nodeName = useSelector((state: RootState) => state.event.event)
const nodeTypes = useMemo(() => ({ start: StartNode, end: EndNode}), []);
```
In the above code I introduced a variable "nodeName" and you might be wondering where I brought that variable from. 

That brings me to the reason why I implemented Redux Toolkit in the first place. The task bar as you can tell from my files above lives in a different component, but those two components share the state that is the the specific label of the task dragged into the pane, so to link those I set up a redux action reducer that stores this label whenever a click and drag from the task lists is initiated.

```JSX
//Here is the task bar on which a listener is attached to that gets the label name and populates that name to a redux state that can in turn be consumed by the above onDrop function that plucks off the variable and use it to populate the node data label

const SideBarTasksTemplate = ({ data, onDragStart }) => {
    const dispatch = useDispatch()
    return(
        <div className="dndnode " onDragStart={(event) => {
            onDragStart(event, 'custom')
            dispatch(addEvent(event.target.innerHTML))
        }} draggable>
             {data}
        </div>
    )
}
```
```JSX
export const eventSlice = createSlice({
    name: "event",
    initialState,
    reducers: {
        addEvent: (state, action) => {
            state.event = action.payload
        } 
    }
})
```
Redux Slicer with the action reducer that receives the state of nodeName and stores it for use by the main React Flow component to render the data.

The tasks are also fetched from Redux store and dynamically rendered into the task bar list.
But this came with an unprecedented problem I faced which I will detail more in the continued development section. 

### Continued development

As I have detailed above introduction of the global state management came with an issue that became evident when I wanted to add more handles, or to elaborate - more exit points from a node. 

More exit nodes are required in each nodes of the flowchart as I might have many conditionals cases of a yes/no and those cases should be treated and distinguished separately. The path a yes case takes us to is different from that of no.

The way we add more Handles or exit points in React Flow is by setting up a custom Node  and adding the handles using its pre-built component <Handle/>, and pass where those exit points shall be situated.

```JSX
//Custom node component
<div className="p-2 cursor-grap rounded-sm bg-white" onDragStart={(event) => {
            onDragStart(event, 'custom')
        }} draggable>
        <Handle type='target' position={Position.Top} id="in"/>
        <Handle type="source" position={Position.Bottom} id="yes" className='-ml-16' />
        <Handle type="source" position={Position.Bottom} id="no" className='ml-16' />
        <Handle type='source' position={Position.Bottom} id="default" className='ml'/>
      {nodeName}
     </div>

//Custom node implemented and passed to root React Component that renders the tree by passing it to React Flow Provider
const nodeTypes = useMemo(() => ({ start: StartNode, end: EndNode, custom: CustomNode}), []);
```

Above is an example of Custom Node I tried to implement with a single target source coming into it and other three nodes leaving it with conditionals of yes, no and default. 

Now the problem arises in that if I am to make the label nodeName dynamically get the nodeName I defined in the Redux state manager and populate it with that, I will face the issue of all the nodes dragged and dropped in the panel being reassigned to that new name. Making them all have the same name. 

![](./public/Screenshot%202023-01-21%20194910.jpg)

Above is a picture that shows it working fine initially, but as I add new and new nodes the already painted and dropped node on the panel gets reassigned by the newly populated data on nodeName, as shown below.

![](./public/Screenshot%202023-01-21%20194947.jpg)

This is what I have been trying to fix, and any suggestions, feedbacks as to how I could solve it is very much appreciated. And this is my progress and journey so far.

Other areas I believe I should work to improve are the interactivity aspect of the diagram from a UX standpoint, migrating all base styling exclusively to use tailwindCSS and other functionalities currently not incorporated in this initial demo.

### Useful resources

- [Official React Flow Documentation](https://reactflow.dev/docs/introduction/) - This helped me learn about React Flow and how to configure it
- [Tailwind Docs](https://tailwindcss.com/docs/) - For miscellaneous styling questions

## Author

- Website - [Mubarek M.Endrie](http://thatutopiancoder.000webhostapp.com/)


